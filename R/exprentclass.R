# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand

#' ExprEntClass
#' 
#' ExprEntClass: We are not orcs, to be smashed and driven. We are Ents, and we have our own ways.
#' this is an R6 object for RNA expression array/matrix analysis,herited from EntClass.
#' 
#' @field hetmap the hetmap
#' @field vocalno the vocalno graph
#' @field gsva matrix the gsva analysis result
#' @field enrichment list the enrichment analysis result
#' @field removebatch_array data.frame the array with batch effects removed
#' @return R6 object
#' 
#' @export
#' @examples
#' ExprEntitem <- ExprEntClass$new()
ExprEntClass <- R6::R6Class(
  "ExprEntClass/ExprSet",
  inherit = EntClass,
  public = list(
    hetmap = NA,
    vocalno = NA,
    gsva = NA,
    enrichment = NA,
    removebatch_array = NA, 
    #' @param removebatch_array logit whether to remove the batch effect
    initialize = function(removebatch_array = FALSE){
      if (!removebatch_array){
      self$removebatch_array <- NULL
      self$hetmap <- NULL
      self$vocalno <- NULL
      } else {
      self$removebatch_array <- self$removeBatch()
      self$hetmap <- self$Plot_hetmap()
      self$vocalno <- self$Plot_vocalno()
      }
      self$gsva <- NULL
      self$enrichmet <- NULL
      self$info()
    },
    #' @method info
    #' 打印R6对象的信息
    #' 
    #' @return str
    info = function(){
      message("ExprEntClass: We are not orcs, to be smashed and driven. We are Ents, and we have our own ways.this is an R6 object for RNA expression array/matrix analysis,herited from EntClass.")
    },
    #' @method remove Batch
    #' @param use_normalize logit use normalize data when true
    #' @return matrix
    removeBatch = function(use_normalize = TRUE){
      if (use_normalize) {
        array <- self$normal_array
      } else {
        array <- self$array
      }
      design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
      mat = limma::removeBatchEffect(array[,-1], batch = self$pdata[[self$batch_index]], design = design)
      mat <- mat %>% dplyr::mutate(GENEID = self$probel) %>% 
        relocate(GENEID)
      self$removebatch_array <- mat
    },
    #' @method Plot hetmap
    #' @param p_thred default as 0.05
    #' @param logFC_thred default as 1
    #' @param topn default as 30
    #' @return fig
    Plot_hetmap = function(p_thred = 0.05,logFC_thred = 1 ,topn = 30){
      if (!is.null(self$removebatch_array)){
        array <- self$removebatch_array
      } else if (!is.null(self$normal_array)){
        array <- self$normal_array
      }else {
        array <- self$array
      }
      library(pheatmap)
      group_sample <- self$pdata %>% dplyr::arrange(.[[self$group_index]])
      group_order <- group_sample[[self$barcode]]
      expr_normal_df2 <- self$array %>% 
        dplyr::select(all_of(group_order))
      rownames(expr_normal_df2) <- self$array[,1]
      group_list <- factor(group_sample[[self$group_index]])
      deg <- self$DA_resutl %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change != "NOT") %>% 
        dplyr::arrange('adj.P.Val')
      display_gene = rownames(deg)
      cg=c(names(head(sort(display_gene),topn)),names(tail(sort(display_gene),topn)))
      n=t(scale(t(expr_normal_df2[cg,])))
      n[n>2]=2
      n[n< -2]= -2
      n[1:4,1:4]
      ac=data.frame(group_list=group_list)
      rownames(ac)=colnames(n)
      p <- pheatmap(n,show_colnames =F,show_rownames = T,annotation_col=ac)
      library(ggplotify)
      p <- as.ggplot(p) + theme(plot.margin = margin(l = 5, r = 10))
      self$hetmap <- p
    },
    #' @method Plot vocalno
    #' @param style_id default as 1,2
    #' @param logFC_thred default as 1
    #' @return fig
    Plot_vocalno = function(style_id,logFC_thred){
      need_deg=data.frame(symbols=rownames(self$DA_resutl), 
                          logFC=self$DA_resutl[["logFC"]], 
                          p=self$DA_resutl[["adj.P.Val"]])
      self$vocano <- AnnoProbe::deg_volcano(need_deg,style_id,logFC_thred = logFC_thred)
    },
    #' @method probel annotate
    #' @return data.frame
    probel_annotate = function(){
      # 创建ENSEMBL到symbol的映射函数
      ensembl2symbol <- function() {
        library(org.Hs.eg.db)
        library(biomaRt)
        # 连接到biomaRt数据库
        mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
        # 获取ENSEMBL到symbol的映射
        ensembl2symbol <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                                filters = "ensembl_gene_id",
                                values = ensembl_ids,
                                mart = mart)
        # 返回映射结果
        return(ensembl2symbol)
      }
      annotate <- ensembl2symbol(self$probel)
      return(annotate)
    },
    #' @method gsva enrich
    #' @param geneSets list the geneSets list
    #' @return data.frame
    gsva_enrich = function(geneSets){
      df <- self$array[,-1]
      rownames(df) <- self$array[,1] 
      df <- df %>%
        as.matrix() %>%
        as.integer() %>% 
        GSVA::gsva(geneSets, method = "md",
             ssgsea.norm = F, verbose = TRUE)  # donot norm
      self$gsva <- df
    },
    #' @method gene enrich
    #' @param pathwaydb chr go or kegg
    #' @param genedb data.frame the genedb data
    #' @return list
    gene_enrich = function(pathwaydb,genedb){
      enrichment_in_action <- function(df,types){
        if (types == "go"){
          result <- clusterProfiler::enrichGO(df, 'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01)
        } else {
          result <- clusterProfiler::enrichKEGG(df, organism = "hsa",
                                                keyType = "kegg",
                                                pvalueCutoff = 0.01,
                                                pAdjustMethod = "BH",
                                                minGSSize = 10,
                                                maxGSSize = 500,
                                                qvalueCutoff = 0.2,
                                                use_internal_data = FALSE)
        }
      }
      gene2entrez <- function(genelist,db = genedb){
        # need further tidy evaluation
        db %>% 
          dplyr::filter(SYMBOL %in% genelist) %>% 
          dplyr::select(ENTREZID) %>% 
          as.vector() %>% 
          unlist()
      }
      enrichlist <- list()
      for (changeType in c("UP","DOWN")){
        DEG <- self$DA_resutl %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change == changeType) %>% 
        dplyr::rownames() %>%
        gene2entrez(genedb) %>% 
        as.vector() %>% unique() %>% 
        enrichment_in_action(types = pathwaydb)
      
      Go_result <- DEG@result %>% 
        tidyr::separate(col=GeneRatio,into = c("GR1", "GR2"), sep = "/") %>% 
        tidyr::separate(col=BgRatio, into = c("BR1", "BR2"), sep = "/") %>% 
        dplyr::mutate(enrichment_factor = (as.numeric(GR1)/as.numeric(GR2))/(as.numeric(BR1)/as.numeric(BR2))) %>% 
        dplyr::mutate(generatio = (as.numeric(GR1)/as.numeric(GR2))) %>% 
        dplyr::arrange(-enrichment_factor)
      enrichlist[[changeType]] <- Go_result 
      }
      self$enrichment <- enrichlist
    }
  )
)
