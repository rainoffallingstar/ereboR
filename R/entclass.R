# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand

#' EntClass
#' 
#' EntClass: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.
#' this is an R6 object for general array/matrix
#' 
#' @field array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @field array_bk data.frame the back up the old data.frame of expression/methylation matrix data, first column is the
#' probel id
#' @field pdata data.frame data.frame of the clinical data of the related matrix data
#' @field probel vector the probel of the matrix
#' @field group_index char the colname of the group infomation in pdata
#' @field batch_index char the colname of the batch_index infomation in pdata
#' @field barcode char the colname of the barcode infomation in pdata
#' @field pca data.frame the PCA analysis result
#' @field tsne data.frame the T-SNE analysis result
#' @field removebatch_array data.frame the array with batch effects removed
#' @field DA_result data.frame the differential analysis result
#' @field projectType expr or methy
#' @return R6 object
#' 
#' @export
#' @examples
#' Entitem <- EntClass$new(array = NULL,pdata = NULL)
EntClass <- R6::R6Class(
  "EntClass/MatrixSet",
  lock_objects = FALSE,
  public = list(
    array = NA,
    array_bk = NA,
    pdata = NA,
    probel = NA,
    group_index = NA,
    batch_index = NA,
    barcode = NA,
    pca = NA,
    tsne = NA,
    removebatch_array = NA,
    DA_result = NA,
    projectType = NA,
#' @param array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @param pdata data.frame data.frame of the clinical data of the related matrix data
#' @param group_index char the colname of the group infomation in pdata
#' @param batch_index char the colname of the batch_index infomation in pdata
#' @param barcode_index char the colname of the barcode infomation in pdata
#' @param normalized logit auto normalized when true
#' @param remove_batch logit auto remove batch effect when true
#' @param differential logit auto differential analysis when true
#' @param projectType expr or methy
    initialize = function(array = NULL,pdata = NULL,
                          group_index = "group",batch_index = "batch",
                          barcode_index = "sampleid",normalized = FALSE,
                          remove_batch = FALSE,differential = FALSE,
                          projectType = c("expr","methy")
                          ){
      self$projectType <- projectType
      if (is.null(array)){
      self$array <- NULL
      self$pdata <- NULL
      self$probel <- NULL
      }else {
      self$array <- array %>% dplyr::select(all_of(c(colnames(array)[1],pdata[[barcode_index]])))
      self$pdata <- pdata
      self$probel <- array[,1]
      }
      self$group_index <- group_index
      self$batch_index <- batch_index
      self$barcode <- barcode_index
      if(normalized){
        self$normalization_transform()
      }
      if (remove_batch){
        self$removeBatch()
      }
      if (differential){
        self$DifferentAnalysis_workflow()
      }
      self$info()
    },
    #' @method info
    #' 打印R6对象的信息
    #' 
    #' @return str
    info = function(){
      message("EntClass/MatrixSet: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.this is an R6 object for general array/matrix")
    },
    #' @method use_remove batch
    #' @return data.frame
    use_removebatch = function(){
      self$array_bk <- self$array
      self$array <- self$removebatch_array
    },
    #' @method probel annotate
    #' @param methyltype chr promoter or cpg
    #' @return data.frame
    probel_annotate = function(methyltype = c("promoter","cpg")){
      if (self$projectType == "expr"){ 
        ensembl2symbol <- function() {
          library(org.Hs.eg.db)
          library(biomaRt)
          # 连接到biomaRt数据库
          mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
          # 获取ENSEMBL到symbol的映射
          ensembl2symbol <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                                filters = "ensembl_gene_id",
                                values = ensembl_ids,
                                mart = mart)
          # 返回映射结果
          return(ensembl2symbol)
        }
        rnaseq_annote4matrix <- function(mds_expr_matrix,duplicate_method = "avg"){
          prfix <- rep(NA,nrow(mds_expr_matrix))
          for (i in 1:nrow(mds_expr_matrix)){
            prfix[i] <- stringr::str_sub(mds_expr_matrix$GENEID[i],1,4)
            }
          g_id <- mds_expr_matrix %>% 
            mutate(prefix = prfix) %>% 
            filter(prefix == "ENSG")
          g_id2 <- g_id$GENEID
          ff <- ensembl2symbol(g_id2)
          colnames(ff) <- c("GENEID","symbol")
          g_id <- g_id %>% 
            dplyr::select(-prefix) %>% 
            left_join(ff,by = "GENEID")
          for (i in 1:nrow(g_id)){
            if (is.na(g_id$symbol[i]) | is.null(g_id$symbol[i])){
              next
              }else {
                g_id$GENEID[i] <- g_id$symbol[i]  
              }
            }
          g_id <- g_id %>% 
            dplyr::select(-symbol) 
          if (duplicate_method == "avg"){
            g_id2 <- aggregate(.~GENEID,mean,data=g_id)
            }else {
              g_id2 <- aggregate(.~GENEID,max,data=g_id)
              }
          g_id2 <- g_id2 %>% filter(!is.null(GENEID)) %>% filter(!is.na(GENEID)) %>% filter(GENEID != "")
          rownames(g_id2) <- g_id2$GENEID
          return(g_id2)
          }

        self$array <- rnaseq_annote4matrix(mds_expr_matrix = self$array,duplicate_method = "avg")
        if(!is.na(self$removebatch_array)){
          self$removebatch_array <- rnaseq_annote4matrix(mds_expr_matrix = self$removebatch_array ,
                                                         duplicate_method = "avg")
        }
        self$probel <- self$array[1,]
      } else {
        rrbs_annote4DMP <- function(DMP_df,type = "cpg",
                            cpg_bedgraph){
          unannote_list <- data.frame(idx = DMP_df)
          if (type == "promoter"){
            g_id <- cpg_bedgraph
            g_id <- g_id %>%
                dplyr::select(-gene_id) %>%
                filter(idx %in% unannote_list$idx)
            } else {
              g_id <- cpg_bedgraph
              for (i in 1:nrow(g_id)){
                if (is.na(g_id$symbol[i]) | is.null(g_id$symbol[i])){
                  g_id$symbol[i] <- g_id$idx[i]
                  }else {
                    next
                  }
                }
              g_id <- g_id %>%
                dplyr::select(-gene_id) %>%
                filter(idx %in% unannote_list$idx)
            }
          return(g_id)
        }
        
        if (methyltype == "cpg"){
          referdata <- cpg_probe
        } else {
          referdata <- promoter_probe
        }
        
        self$probel <- rrbs_annote4DMP(self$probel, type = methyltype, cpg_bedgraph = referdata)
        
      }
    },

    #' @method remove Batch
    #' @return matrix
    removeBatch = function(){
      rrbs_ComBat2batcheffects <- function(beta,
                                     pd,
                                     variablename = "group",
                                     batchname="batch",
                                     logitTrans=TRUE){
        print("this function is adopted from chAMP.")
        if(length(which(is.na(beta)))>0) message(length(which(is.na(beta)))," NA are detected in your beta Data Set, which may cause fail or uncorrect of runCombat analysis.")
        if ("data.frame" %in% class(beta)){print("we repuire a methylationSet in the format of data.frame as input")}
        if ("data.frame" %in% class(pd)){print("we repuire a pd in the format of data.frame as input")}
        if(is.null(variablename) | !variablename %in% colnames(pd)) stop("variablename parameter MUST contains variable in pd file.")
        valid.idx <- which(!colnames(pd) == variablename & apply(pd,2,function(x) length(unique(x)))!=1)
        if(length(valid.idx)==0) stop("There is no valid factor can be corrected. Factor can be corrected must contian at least two phenotypes. Also batch factors can be variable factor. Please check if your covariates fulfill these requirement.")
        PhenoTypes.lv_tmp <- pd[,valid.idx]
        PhenoTypes.lv_tmp <- apply(PhenoTypes.lv_tmp,2,function(x) as.character(x))
        PhenoTypes.lv <- as.data.frame(apply(PhenoTypes.lv_tmp,2,function(x) if(inherits(x,"numeric"))
          as.factor(as.numeric(as.factor(x)))))
        if(!is.null(rownames(pd))) rownames(PhenoTypes.lv) <- rownames(pd)
        if(ncol(PhenoTypes.lv)>=1){
          message("<< Following Factors in your pd(sample_sheet.csv) could be applied to Combat: >>")
          sapply(colnames(PhenoTypes.lv_tmp),function(x) message("<",x,">(",class(PhenoTypes.lv[[x]]),")"))
          message("[Combat have automatically select ALL factors contain at least two different values from your
                  pd(sample_sheet.csv).]")
          }else{
            stop("You don't have even one factor with at least two value to be analysis. Maybe your factors contains only one value, no variation at all...")
            }
        if(ncol(pd) > ncol(PhenoTypes.lv)){
          message("\n<< Following Factors in your pd(sample_sheet.csv) can not be corrected: >>")
          sapply(setdiff(colnames(pd),colnames(PhenoTypes.lv)),function(x) message("<",x,">"))
          message("[Factors are ignored because they are conflict with variablename, or they contain ONLY ONE value
                  across all Samples, or some phenotype contains less than 2 Samples.]")
          }
        if(all(batchname %in% colnames(PhenoTypes.lv))){
          message("As your assigned in batchname parameter: ",paste(batchname,collapse=",")," will be corrected by
                  Combat function.")
          }else{
            stop(setdiff(batchname,colnames(PhenoTypes.lv))," factors is not valid to run Combat, please recheck your
                 dataset.")
            }
        beta_2 <- beta
        beta_colnames <- colnames(beta)
        beta_rownames <- beta[,1]
        beta <- beta[,-1]
        if(min(beta)<=0 & logitTrans == TRUE){
          message("Zeros in your dataset have been replaced with smallest positive value.")
          beta[beta<=0] <- min(beta[beta > 0])
          }
        print(beta)
        print("check beta in zeros")
        rownames(beta) <- beta_rownames
        #Following four find empirical hyper-prior values
        aprior <- function(gamma.hat) {
          m <- mean(gamma.hat)
          s2 <- var(gamma.hat)
          (2*s2 + m^2) / s2
        }
        
        bprior <- function(gamma.hat){
            m <- mean(gamma.hat)
            s2 <- var(gamma.hat)
            (m*s2 + m^3) / s2
        }
        innercombat <- function(beta,beta_2,batch_temp,formdf,pd,logitTrans){
          library(minfi)
          if(logitTrans){
            beta <- logit2(beta)
            }
          print(formdf)
          print(batch_temp)
          mod <- model.matrix(formdf,data=pd)
          print(mod)
          message("Generate mod success. Started to run ComBat, which is quite slow...")
          combat <- sva::ComBat(dat=beta,batch=batch_temp,mod=mod)
          print("checked")
          if(logitTrans){
            combat=ilogit2(combat)
            }
          if (is.na(combat[1,1])){
            print("found na,try another")
            combat <- sva::ComBat(dat = beta_2[,-1],pd$batch,mod = mod)
            }
          return(combat)
          }
        library(sva)
        #i = 1
        for(i in 1:length(batchname)){
          message("\n<< Start Correcting ",batchname[i]," >>")
          if(i+1 <= length(batchname)){
            formdf <- as.formula(paste(" ~ ",paste(c(variablename,batchname[(i+1):length(batchname)]),collapse=" +
                                                   "),sep=""))
            }else{
              formdf <- as.formula(paste(" ~",variablename))
              }
          batch_temp <- pd[,batchname[i]] %>% unlist()
          print(batch_temp)
          print(formdf)
          beta <- innercombat(beta,beta_2,batch_temp,formdf,pd = pd,logitTrans = logitTrans)
          }
        beta <- as.data.frame(beta)
        beta <- beta %>% mutate(idx = beta_rownames) %>% relocate(idx)
        if(is.null(beta)){
          message("Sorry, Combat process run failed. Your old dataset will be returned.")
          return(beta_2)
          }else{
            message("Combat process run success. Corrected dataset will be returned.")
            return(beta)
            }
        message("[<<< COMBAT END >>>]")
        }
      if (self$projectType == "expr"){
        design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
        mat = limma::removeBatchEffect(self$array[,-1], batch = self$pdata[[self$batch_index]], design = design)
        mat <- mat %>% dplyr::mutate(GENEID = self$probel) %>% relocate(GENEID)
        self$removebatch_array <- mat
      } else {
        mat <- rrbs_ComBat2batcheffects(beta = self$array,
                                     pd = self$pdata,
                                     variablename = self$group_index,
                                     batchname=self$batch_index,
                                     logitTrans=TRUE)
        self$removebatch_array <- mat
      }
      
    },
    #' @method feature filter
    #' @param pct num range(0-1), the ratetio to filter
    #' @return matrix
    feature_filter = function(pct = 0.8){
      data_expr <- self$array[,-1]
      # Calculating variation
      cv_value <- apply(data_expr,1, function(x) sd(x,na.rm = TRUE) / mean(x,na.rm = TRUE) * 100)
      # Filtering
      self$array <- self$array %>%
        dplyr::mutate(cv = cv_value) %>% 
        dplyr::top_frac(pct,cv) %>% 
        dplyr::select(-cv)
    },
    #' @method Plot PCA
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    PlotPCA = function(ntop = 500,batchremove = FALSE){
      if (batchremove){
        array <- self$removebatch_array[,-1] %>% as.matrix()
      } else {
        array <- self$array[,-1] %>% as.matrix()
      }
        # calculate the variance for each row
        
        pdata <- self$pdata
        batchname <- c(self$group_index,self$batch_index)
        rv <- rowVars(array)
        # select the ntop rows by variance
        select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
        # perform a PCA on the data in assay(x) for the selected genes
        pca <- prcomp(t(array[select,]))
        # the contribution to the total variance for each component
        percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
        if (!all(batchname %in% colnames(pdata))) {
          stop("the argument 'intgroup' should specify columns of pd")
        }
        intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
        # add the intgroup factors together to create a new grouping factor
        group <- if (length(batchname) > 1) {
          factor(apply( intgroup.df, 1, paste, collapse=":"))
        } else {
          pd[[batchname]]
        }
        # assembly the data for the plot
        d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], groups=group, intgroup.df, name=colnames(object))
        self$pca <- d
        p <- ggplot(d, aes(PC1, PC2)) +
          geom_point(aes(shape = .[[self$group_index]], color = .[[self$batch_index]]), size = 3)
        return(p)
    },
    #' @method Plot SNE
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @param dim num the dim of Rtsne,default as 2
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    PlotSNE = function(ntop = 500,dim = 2,batchremove = FALSE){
      # To-Do,some var should be fix in tsne analysis
      # calculate the variance for each row
      if (batchremove){
        array <- self$removebatch_array[,-1] %>% as.matrix()
      } else {
        array <- self$array[,-1] %>% as.matrix()
      }
      pdata <- self$pdata
      batchname <- c(self$group_index,self$batch_index)
      rv <- rowVars(array)
      # select the ntop rows by variance
      select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
      # perform a tSNE on the data in assay(x) for the selected genes
      tSNE_result <- Rtsne::Rtsne(array[select,], dims = dim)
      # the contribution to the total variance for each component
      percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
      if (!all(batchname %in% colnames(pdata))) {
        stop("the argument 'intgroup' should specify columns of pd")
      }
      intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
      # add the intgroup factors together to create a new grouping factor
      group <- if (length(batchname) > 1) {
        factor(apply( intgroup.df, 1, paste, collapse=":"))
      } else {
        pd[[batchname]]
      }
      # assembly the data for the plot
      d <- data.frame(X = tSNE_result$Y[, 1], Y = tSNE_result$Y[, 2], groups = group)
      self$tsne <- d
      p <- ggplot(d, aes(X, Y)) +
        geom_point(aes(color = groups), size = 3)
      return(p)
    },
    #' @method to ExprSet
    #' @return R6_object
    toExprSet = function(){
      newitem <- ExprEntClass$new(self$array,self$pdata,
                                  self$group_index,self$batch_index,
                                  self$barcode_index,self$removebatch_array,
                                  self$DA_result)
      return(newitem)
    },
    #' @method to ExprSet
    #' @return R6_object
    toMethySet = function(){
      newitem <- MethylEntClass$new(self$array,self$pdata,
                                    self$group_index,self$batch_index,
                                    self$barcode_index,self$removebatch_array,
                                    self$DA_result)
      return(newitem)
    },
    #' @method normalization transform
    #' @param .keep logit whether to replace the old array directly,default as TRUE (create the normal_array)
    #' @return data.frame
    normalization_transform = function(.keep = TRUE){
      matrixdf <- self$array[,-1] %>% as.matrix()
      matrixdf <- log2(matrixdf) %>% 
        as.data.frame(result) %>% mutate(idx = self$probel) %>% relocate(idx)
      if (.keep){
        self$normal_array <- matrixdf
      } else {
        self$array <- matrixdf
      }
    },
    #' @method Different Analysis_workflow 
    #' @param adjust.method chr the adjust.method of limma
    #' @param adjPVal num the adjust p value, default as 0.05
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    DifferentAnalysis_workflow = function(adjust.method = "BH",adjPVal = 0.05,batchremove = FALSE){
      if (batchremove){
        beta <- self$removebatch_array[,-1] 
        rownames(beta) <- self$removebatch_array[,1] 
      } else {
        beta <- self$array[,-1]
        rownames(beta) <- self$array[,1]
      }
      library(limma)
      design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
      colnames(design) <- levels(factor(self$pdata[[self$group_index]]))
      contrast.matrix <- makeContrasts(contrasts=paste(colnames(design)[2:1],collapse="-"), levels=colnames(design))
      message("Contrast Matrix")
      print(contrast.matrix)
      fit <- lmFit(beta, design)
      fit2 <- contrasts.fit(fit,contrast.matrix)
      tryCatch(fit3 <- eBayes(fit2),
               warning=function(w) 
               {stop("limma failed, No sample variance.\n")})
      DMP <- topTable(fit3,coef=1,number=nrow(beta),adjust.method=adjust.method,p.value=adjPVal)
      message("You have found ",sum(DMP$adj.P.Val <= adjPVal), " significant items with a ",adjust.method," adjusted P-value below ", adjPVal,".")
      if (nrow(DMP) == 0){
        message("seems bad,adjusting")
        DMP <- topTable(fit3,coef=1,n = Inf)
      }
      message("Calculate done.")
      self$DA_result <- DMP
    }
  )
)

