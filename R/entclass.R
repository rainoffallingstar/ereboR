# WARNING - Generated by {fusen} from dev/flat_first.Rmd: do not edit by hand

#' EntClass
#' 
#' EntClass: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.
#' this is an R6 object for general array/matrix
#' 
#' @field array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @field pdata data.frame data.frame of the clinical data of the related matrix data
#' @field probel vector the probel of the matrix
#' @field group_index char the colname of the group infomation in pdata
#' @field batch_index char the colname of the batch_index infomation in pdata
#' @field barcode char the colname of the barcode infomation in pdata
#' @field pca data.frame the PCA analysis result
#' @field tsne data.frame the T-SNE analysis result
#' @field normal_array data.frame the normalized array
#' @field DA_result data.frame the differential analysis result
#' @return R6 object
#' 
#' @export
#' @examples
#' Entitem <- EntClass$new(array = NULL,pdata = NULL)
EntClass <- R6::R6Class(
  "EntClass/MatrixSet",
  lock_objects = FALSE,
  public = list(
    array = NA,
    pdata = NA,
    probel = NA,
    group_index = NA,
    batch_index = NA,
    barcode = NA,
    pca = NA,
    tsne = NA,
    normal_array = NA,
    DA_result = NA,
#' @param array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @param pdata data.frame data.frame of the clinical data of the related matrix data
#' @param group_index char the colname of the group infomation in pdata
#' @param batch_index char the colname of the batch_index infomation in pdata
#' @param barcode_index char the colname of the barcode infomation in pdata
    initialize = function(array = NULL,pdata = NULL,
                          group_index = "group",batch_index = "batch",barcode_index = "sampleid"
                          ){
      if (is.null(array)){
      self$array <- NULL
      self$pdata <- NULL
      self$probel <- NULL
      }else {
      self$array <- array %>% dplyr::select(all_of(c(colnames(array)[1],pdata[[barcode_index]])))
      self$pdata <- pdata
      self$probel <- array[,1]
      }
      self$group_index <- group_index
      self$batch_index <- batch_index
      self$barcode <- barcode_index
      self$pca <- NULL
      self$tsne <- NULL
      self$normal_array <- NULL
      self$DA_result <- NULL
      self$info()
    },
    #' @method info
    #' 打印R6对象的信息
    #' 
    #' @return str
    info = function(){
      message("EntClass/MatrixSet: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.this is an R6 object for general array/matrix")
    },
    #' @method feature filter
    #' @param pct num range(0-1), the ratetio to filter
    #' @return matrix
    feature_filter = function(pct = 0.8){
      data_expr <- self$array[,-1]
      # Calculating variation
      cv_value <- apply(data_expr,1, function(x) sd(x,na.rm = TRUE) / mean(x,na.rm = TRUE) * 100)
      # Filtering
      self$array <- self$array %>%
        dplyr::mutate(cv = cv_value) %>% 
        dplyr::top_frac(pct,cv) %>% 
        dplyr::select(-cv)
    },
    #' @method Plot PCA
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @return data.frame
    PlotPCA = function(ntop = 500){
        # calculate the variance for each row
        array <- self$array[,-1] %>% as.matrix()
        pdata <- self$pdata
        batchname <- c(self$group_index,self$batch_index)
        rv <- rowVars(array)
        # select the ntop rows by variance
        select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
        # perform a PCA on the data in assay(x) for the selected genes
        pca <- prcomp(t(array[select,]))
        # the contribution to the total variance for each component
        percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
        if (!all(batchname %in% colnames(pdata))) {
          stop("the argument 'intgroup' should specify columns of pd")
        }
        intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
        # add the intgroup factors together to create a new grouping factor
        group <- if (length(batchname) > 1) {
          factor(apply( intgroup.df, 1, paste, collapse=":"))
        } else {
          pd[[batchname]]
        }
        # assembly the data for the plot
        d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], groups=group, intgroup.df, name=colnames(object))
        self$pca <- d
        p <- ggplot(d, aes(PC1, PC2)) +
          geom_point(aes(shape = .[[self$group_index]], color = .[[self$batch_index]]), size = 3)
        return(p)
    },
    #' @method Plot SNE
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @param dim num the dim of Rtsne,default as 2
    #' @return data.frame
    PlotSNE = function(ntop = 500,dim = 2){
      # To-Do,some var should be fix in tsne analysis
      # calculate the variance for each row
      array <- self$array[,-1] %>% as.matrix()
      pdata <- self$pdata
      batchname <- c(self$group_index,self$batch_index)
      rv <- rowVars(array)
      # select the ntop rows by variance
      select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
      # perform a tSNE on the data in assay(x) for the selected genes
      tSNE_result <- Rtsne::Rtsne(array[select,], dims = dim)
      # the contribution to the total variance for each component
      percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
      if (!all(batchname %in% colnames(pdata))) {
        stop("the argument 'intgroup' should specify columns of pd")
      }
      intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
      # add the intgroup factors together to create a new grouping factor
      group <- if (length(batchname) > 1) {
        factor(apply( intgroup.df, 1, paste, collapse=":"))
      } else {
        pd[[batchname]]
      }
      # assembly the data for the plot
      d <- data.frame(X = tSNE_result$Y[, 1], Y = tSNE_result$Y[, 2], groups = group)
      self$tsne <- d
      p <- ggplot(d, aes(X, Y)) +
        geom_point(aes(color = groups), size = 3)
      return(p)
    },
    #' @method to ExprSet
    #' @return R6_object
    toExprSet = function(){
      newitem <- ExprEntClass$new(self$array,self$pdata,
                                  self$group_index,self$batch_index,
                                  self$barcode_index,self$normal_array,
                                  self$DA_result)
      return(newitem)
    },
    #' @method to ExprSet
    #' @return R6_object
    toMethySet = function(){
      newitem <- MethylEntClass$new(self$array,self$pdata,
                                    self$group_index,self$batch_index,
                                    self$barcode_index,self$DA_result)
      return(newitem)
    },
    #' @method normalization transform
    #' @param .keep logit whether to replace the old array directly,default as TRUE (create the normal_array)
    #' @return data.frame
    normalization_transform = function(.keep = TRUE){
      matrixdf <- self$array[,-1] %>% as.matrix()
      matrixdf <- log2(matrixdf) %>% 
        as.data.frame(result) %>% mutate(idx = self$probel) %>% relocate(idx)
      if (.keep){
        self$normal_array <- matrixdf
      } else {
        self$array <- matrixdf
      }
    },
    #' @method Different Analysis_workflow 
    #' @param adjust.method chr the adjust.method of limma
    #' @param adjPVal num the adjust p value, default as 0.05
    #' @return data.frame
    DifferentAnalysis_workflow = function(adjust.method = "BH",adjPVal = 0.05){
      library(limma)
      beta <- self$array[,-1]
      rownames(beta) <- self$array[,1]
      design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
      colnames(design) <- levels(factor(self$pdata[[self$group_index]]))
      contrast.matrix <- makeContrasts(contrasts=paste(colnames(design)[2:1],collapse="-"), levels=colnames(design))
      message("Contrast Matrix")
      print(contrast.matrix)
      fit <- lmFit(beta, design)
      fit2 <- contrasts.fit(fit,contrast.matrix)
      tryCatch(fit3 <- eBayes(fit2),
               warning=function(w) 
               {stop("limma failed, No sample variance.\n")})
      DMP <- topTable(fit3,coef=1,number=nrow(beta),adjust.method=adjust.method,p.value=adjPVal)
      message("You have found ",sum(DMP$adj.P.Val <= adjPVal), " significant items with a ",adjust.method," adjusted P-value below ", adjPVal,".")
      if (nrow(DMP) == 0){
        message("seems bad,adjusting")
        DMP <- topTable(fit3,coef=1,n = Inf)
      }
      message("Calculate done.")
      self$DA_result <- DMP
    }
  )
)

