---
title: "ereboR: an R6-based package in dealing with bulk RNA-seq & cfDNA RRBS data"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- 
Run this 'development' chunk

Store every call to library() that you need to run chunks line by line, as in a classical Rmd for analysis
-->

```{r development, include=FALSE}
library(testthat)
```

<!--
# Description of your package

This will fill the description of your package.
Fill and run the content of this chunk, before anything else. 

Note: when you will use other flat templates, this part will be in a separate file. Do not be surprised!
--> 

```{r description, eval=FALSE}
fusen::fill_description(
  overwrite = TRUE,
  pkg = here::here(),
  fields = list(
    Title = "erebor",
    Description = "erebor: an R6-based package in dealing with bulk RNA-seq & cfDNA RRBS data.",
    `Authors@R` = c(
      person("Yanhua", "Zheng", email = "yhzheng@cmu.edu.cn", role = c("aut", "cre"), comment = c(ORCID = "0000-0003-1103-9579"))
    )
  )
)

# Define License with use_*_license()
usethis::use_mit_license("YanhuaZheng")

usethis::use_readme_rmd()
usethis::use_package("dplyr")
usethis::use_package("fs")
usethis::use_package("glue")
usethis::use_package("stringr")
usethis::use_package("readr")
usethis::use_package("data.table")
usethis::use_pipe()
usethis::use_package("TCGAbiolinks")
usethis::use_package("SummarizedExperiment")
usethis::use_package("GEOquery")
```



# bagginsclass
    
```{r function-bagginsclass}
#' Human Entrez Gene Id Database
#' @name Entrez_Gene_Id_db
#' @description A database of Entrez Gene IDs with associated information.
#' @format A data frame with columns for Entrez Gene IDs and annotations.


#' BagginsClass
#' 
#' BagginsClass：I am going on an adventure! this is an R6 object for rnaseq upstream workflow
#' @field root_dir character Path to the working directory for BAGGINS.
#' @field bamfiles_dir character Path to the directory containing aligned BAM files.
#' @field countfiles_dir character Path to the directory containing count files.
#' @field refer_genome character Path to the reference genome used for alignment.
#' @field gtf_file character Path to the annotation file in GTF format.
#' @field samtools_exe character Path to the SAMtools executable.
#' @field htseq_exe character Path to the HTSeq executable.
#' @field star_exe character Path to the STAR executable.
#' @field clean_str unnecessary str in the filenames
#' @return R6 object
#' 
#' @export
BagginsClass <- R6::R6Class(
  "rnaseq_workflow",
  public = list(
    root_dir = NA,bamfiles_dir = NA,
    countfiles_dir= NA,refer_genome = NA,gtf_file = NA,
    samtools_exe = NA ,htseq_exe = NA ,star_exe = NA,
    clean_str = "Aligned.sortedByCoord.out.bam_counts.txt",

#' @param root_dir 根目录的路径
#' @param bamfiles_dir BAM文件目录的路径
#' @param countfiles_dir 计数文件目录的路径
#' @param refer_genome 参考基因组的路径
#' @param gtf_file GTF文件的路径
#' @param samtools_exe SAMtools可执行文件的路径
#' @param htseq_exe HTSeq可执行文件的路径
#' @param star_exe STAR可执行文件的路径
#' @param clean_str 清理字符串的值

    
    initialize = function(root_dir = NA,bamfiles_dir = NULL,
                          countfiles_dir = NULL,refer_genome = NULL,gtf_file = NULL,
                          samtools_exe = NULL ,htseq_exe = NULL ,star_exe = NULL,
                          clean_str = "Aligned.sortedByCoord.out.bam_counts.txt"){
      self$root_dir <- root_dir
      self$bamfiles_dir <- bamfiles_dir
      self$countfiles_dir<- countfiles_dir
      self$refer_genome <- refer_genome
      self$gtf_file <- gtf_file
      self$samtools_exe <- samtools_exe
      self$htseq_exe <- htseq_exe
      self$star_exe <- star_exe
      self$clean_str = clean_str
      self$info()
    },
#' @method info
#' 打印R6对象的信息
#' 
#' @return NULL
    info = function(){
      message("BagginsClass：I am going on an adventure! this is an R6 object for rnaseq upstream workflow ")
    },
#' @method initialize_dirs
#' 初始化R6对象的目录
#' 
#' @return NULL
    initialize_dirs = function(){
      rnaseq_placefile <- function(root_dir){
        files <- list.files(root_dir)
        file_ids <- rep(NA,length(files))
        for (i in 1:length(files)) {
          file_ids[i] <- stringr::str_split(files[i],"_")[[1]] %>% unlist()
        }
        
        for (file_id in file_ids){
          fs::dir_create(paste0(root_dir,"/",file_id))
          fs::dir_create(glue::glue("{root_dir}/bam_files"))
          fs::dir_create(glue::glue("{root_dir}/bam_files/{file_id}"))
        }
        df <- data.frame(id = file_ids,dir = files) %>% 
          dplyr::mutate(origin_dir = paste0(root_dir,"/",files),
                 dest_dir = paste0(root_dir,"/",id,"/",files),
          )
        for (i in 1:nrow(df)) {
          fs::file_move(df$origin_dir[i],df$dest_dir[i])
        }
      }
      print("info,preparing files and dirs for following use")
      fs::dir_create(self$bamfiles_dir)
      fs::dir_create(self$countfiles_dir)
      rnaseq_placefile(self$root_dir)
    },
#' @method fastq2matrix
#' 将fastq文件转换为矩阵
#' 
#' @return 转换后的矩阵
    fastq2matrix = function(){
      ## 将一组样本的R1和R2 RNA_seq一同对比，使用STAR软件
      rnaseq_star2annate <- function(star_exe,root_dir,refer_genome,bamfiles_dir){
        sample_list <- list.files(root_dir,"\\.fastq.gz",recursive = TRUE)
        for (sample in sample_list){
          input_dir = paste0(root_dir,sample)
          output_dir = paste0(bamfiles_dir,"/",sample)
          fastq_files = list.files(input_dir)
          fastq_r1 = paste0(input_dir,"/",fastq_files[1])
          fastq_r2 = paste0(input_dir,"/",fastq_files[2])
          system(paste(star_exe,
                       '--runThreadN', '8',
                       '--readFilesCommand', 'zcat',
                       '--quantMode', 'GeneCounts',
                       '--genomeDir', refer_genome,
                       '--readFilesIn', fastq_r1,fastq_r2,
                       '--twopassMode', 'Basic',
                       '--outSAMunmapped', 'None',
                       '--outSAMtype', 'BAM', 'SortedByCoordinate',
                       '--outFileNamePrefix', output_dir))
        }
      }
      rnaseq_bam4index <- function(samtool_exe,root_dir){
        bam_file_all <- list.files(root_dir,".bam",recursive = TRUE)
        for ( i in 1:length(bam_file_all)) {
          origin_path <- paste0(root_dir,'/',bam_file_all[i])
          print(paste("now we are working on",bam_file_all[i]))
          system(
            paste(samtool_exe,"index",origin_path))
        }
      }
      
      # 从rnaseq的bam文件进行未矫正的表达定量，使用HTSeq
      rnaseq_bam2counts <- function(htseq_exe,root_dir,gtf_dir,output_dir){
        # htseq-count -f bam -s no -t gene -i gene_id input.bam genes.gtf > counts.txt
        file_ids <- list.files(root_dir,".out.bam",recursive = TRUE)
        #file_lable <- rep(NA,length(file_ids))
        fs::dir_create(output_dir)
        for (i in 1:length(file_ids)){
          print(paste("now working on ",file_ids[i]))
          file_lable <- stringr::str_split(file_ids[i],"\\/")[[1]][2]
          #/home/rstudio/.local/bin/htseq-count -h
          system(
            paste(htseq_exe," -f bam -s no -t exon -i gene_id",
                  paste0("mds_expr/bam_files/",file_ids[i]),
                  gtf_dir,
                  ">",
                  paste0(output_dir,file_lable,"_counts.txt"))
          )
        }
      }
      rnaseq_count2matrix <- function(count_dir,clean_str = "Aligned.sortedByCoord.out.bam_counts.txt"){
        count_files <- list.files(count_dir,".txt")
        count_list <- list()
        for (i in 1:length(count_files)){
          count_lable <- stringr::str_remove(count_files[i],clean_str)
          count_table <- readr::read_tsv(paste0(count_dir,"/",count_files[i]),
                                         col_names = FALSE) %>% 
            dplyr::mutate(X2 = as.numeric(X2))
          colnames(count_table) <- c("GENEID",count_lable)
          count_list[[i]] <- count_table
          names(count_list)[i] <- count_lable
        }
        expr_df <- count_list[[1]] %>% 
          dplyr::left_join(count_list[[2]],by = "GENEID")
        for (i in 3:length(count_list)) {
          temp_df <- expr_df %>% 
            dplyr::left_join(count_list[[i]])
          expr_df <- temp_df
        }
        return(expr_df)
      }
      print("info,Step 1, refer the fastq files to genome")
      rnaseq_star2annate(self$star_exe,self$root_dir,self$refer_genome,self$bamfiles_dir)
      print("info,Step 2, index bam files and build count files in txt")
      rnaseq_bam4index(self$samtools_exe,self$bamfiles_dir)
      rnaseq_bam2counts(self$htseq_exe,self$bamfiles_dir,self$gtf_file,self$countfiles_dir)
      print("info,Step 3,build expression matrix ")
      df <- rnaseq_count2matrix(self$countfiles_dir,self$clean_str)
      return(df)
    }
    
  )
  
)
```
  
```{r example-bagginsclass}
workflow <- BagginsClass$new(root_dir = ".")
```
  
```{r tests-bagginsclass}
test_that("bagginsclass works", {
  expect_true(inherits(BagginsClass, "R6ClassGenerator")) 
})
```
  
# samwiseclass
    
```{r function-samwiseclass}
#' CpG island with gene annotation
#' @name cpg_probe
#' @description A database of CpG island with gene annotation information.
#' @format A data frame with CpG island with gene annotation.

#' SamwiseClass
#' 
#' SamwiseClass:It's the job that's never started takes longest to finish.this is an R6 object for rrbs upstream workflow
#' @field root_dir character NULL 根目录的路径。
#' @field methyratio_dir character NULL 存储methyratio文件的目录的路径。
#' @field cpgmethy_dir character NULL 存储CpG甲基化文件的目录的路径。
#' @field cpgmethy_optimize character NULL 优化后的CpG甲基化文件的目录的路径。
#' @field promotermethy_optimize character NULL 优化后的启动子甲基化文件的目录的路径。
#' @field promotermethy_dir character NULL 存储启动子甲基化文件的目录的路径。
#' @field methyratio_py character NULL 用于计算methyratio的Python脚本的路径。
#' @field gene_fa character NULL 基因组序列的FASTA文件的路径。
#' @field bedtools_exe character NULL BEDTools可执行文件的路径。
#' @field cpg_bedfiles character NULL CpG岛的bed文件的路径。
#' @field promoter_bedfiles character NULL 启动子区域的bed文件的路径。
#' @field type character "promoter" 甲基化分析的类型（"cpg"或"promoter"）。
#' @field matrix_type character "Beta-value" 矩阵表示的类型（"Beta-value"或"M-value"）。
#' @field chrsex character "dame" 染色体性别（"dame"或"male"）。
#' 
#' @return R6 object
#' 
#' @export
SamwiseClass <- R6::R6Class(
  "rrbs_workflow", 
  public = list(
    root_dir = NULL, methyratio_dir = NULL, cpgmethy_dir = NULL,
    cpgmethy_optimize = NULL, promotermethy_optimize = NULL, promotermethy_dir = NULL, methyratio_py = NULL, gene_fa = NULL,
    bedtools_exe = NULL, cpg_bedfiles = NULL, promoter_bedfiles = NULL, type = "promoter", matrix_type = "Beta-value",
    chrsex = "dame", 
#' @method initialize
#' 初始化R6对象的构造函数。
#' @param root_dir character NULL 根目录的路径。
#' @param methyratio_dir character NULL 存储methyratio文件的目录的路径。
#' @param cpgmethy_dir character NULL 存储CpG甲基化文件的目录的路径。
#' @param cpgmethy_optimize character NULL 优化后的CpG甲基化文件的目录的路径。
#' @param promotermethy_optimize character NULL 优化后的启动子甲基化文件的目录的路径。
#' @param promotermethy_dir character NULL 存储启动子甲基化文件的目录的路径。
#' @param methyratio_py character NULL 用于计算methyratio的Python脚本的路径。
#' @param gene_fa character NULL 基因组序列的FASTA文件的路径。
#' @param bedtools_exe character NULL BEDTools可执行文件的路径。
#' @param cpg_bedfiles character NULL CpG岛的bed文件的路径。
#' @param promoter_bedfiles character NULL 启动子区域的bed文件的路径。
#' @param type character "promoter" 甲基化分析的类型（"cpg"或"promoter"）。
#' @param matrix_type character "Beta-value" 矩阵表示的类型（"Beta-value"或"M-value"）。
#' @param chrsex character "dame" 染色体性别（"dame"或"male"）。 
#' @return R6对象的实例。
    initialize = function(root_dir = NA, methyratio_dir = NA, 
                          cpgmethy_dir = NA, cpgmethy_optimize = NA,
                          promotermethy_optimize = NA, promotermethy_dir = NA, methyratio_py = "methratio.py",
                          gene_fa = "Genedata/hg19.fa", bedtools_exe = "bedtools", 
                          cpg_bedfiles ="Genedata/cpg_islands_hg19.bedgraph",
                          promoter_bedfiles = "Genedata/promoter_hg19_ensGene.bedgraph", type = "cpg", 
                          matrix_type = "Beta-value", chrsex = "dame") {
    self$root_dir <- root_dir
    self$methyratio_dir <- glue::glue("{root_dir}/bed_files")
    self$cpgmethy_dir <- glue::glue("{root_dir}/cpg_methy")
    self$cpgmethy_optimize <- glue::glue("{root_dir}/cpg_methy_optimize")
    self$promotermethy_optimize <- glue::glue("{root_dir}/promoter_methy_optimize")
    self$promotermethy_dir <- glue::glue("{root_dir}/promoter_methy")
    self$methyratio_py <- methyratio_py
    self$gene_fa <- gene_fa
    self$bedtools_exe <- bedtools_exe
    self$cpg_bedfiles <- cpg_bedfiles
    self$promoter_bedfiles <- promoter_bedfiles
    self$type <- type
    self$matrix_type <- matrix_type
    self$chrsex <- chrsex
    self$info()
  },
#' @method info
#' 打印R6对象的信息
#' 
#' @return str
  info = function() {
    message("SamwiseClass:It's the job that's never started takes longest to finish.this is an R6 object for rrbs upstream workflow")
  },
#' @method initialize_dirs
#' 初始化R6对象的目录
#' 
#' @return NULL

initialize_dirs = function() {
    print(paste("info, Step 1,creat dirs for further use, as the following workflow after BSMSP-based procedure"))
    fs::dir_create(self$methyratio_dir)
    fs::dir_create(self$cpgmethy_dir)
    fs::dir_create(self$cpgmethy_optimize)
  }, 
#' @method bam2methyratio
#' 从BAM文件中计算methyratio值
#'
#' @return methyratio
bam2methyratio = function() {
    print(paste("info, Step 2, Get methyratio values from bam files and transfer to bedgraph files"))
    bamfiles <- list.files(self$root_dir, pattern = "\\.bam$", recursive = FALSE)
    fs::dir_create(self$methyratio_dir)
    fs::dir_create(paste0(self$root_dir, "/temp"))
    fs::dir_create(paste0(self$root_dir, "/processed"))
    for (i in 1:length(bamfiles)) {
      print(paste("info,", paste0(i, "/", length(bamfiles)), ",start processing methyratio values", bamfiles[i]))
      output_dir_txt <- paste0(self$root_dir, "/temp/", "methyratio_", stringr::str_replace(bamfiles[i], ".bam",
        ".txt"))
      output_dir_bed <- paste0(self$methyratio_dir, "/", "methyratio_", stringr::str_replace(bamfiles[i], ".bam",
        ".bedgraph"))
      # python3 /home/rstudio/methy2expr/dev/BSMAPz-master/methratio.py -o test.txt
      #-d /home/rstudio/methy2expr/dev/hg19/hg19.fa 23T035358.bam
      system(paste("python2", self$methyratio_py, "-I -o", output_dir_txt, "-d", self$gene_fa, paste0(self$root_dir,
        "/", bamfiles[i])))
      print(paste("info,", paste0(i, "/", length(bamfiles)), ",start packing bedgraph files", bamfiles[i]))
      # 禁用科学计数法
      options(scipen = 9999)
      temp_df <- data.table::fread(output_dir_txt, header = TRUE, stringsAsFactors = FALSE) %>%
        dplyr::select(chr, pos, ratio) %>%
        dplyr::mutate(start = as.character(as.numeric(pos) - 1)) %>%
        dplyr::rename(end = pos) %>%
        dplyr::select(chr, start, end, ratio)
      data.table::fwrite(temp_df, file = output_dir_bed, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
      print(paste("info,", paste0(i, "/", length(bamfiles)), ",start clean files in temp dirs with txt and bam"))
      fs::file_delete(output_dir_txt)
      fs::file_delete(paste0(self$root_dir, "/", bamfiles[i]))
      fs::file_move(paste0(self$root_dir, "/", stringr::str_replace(bamfiles[i], ".bam", ".tmpSrt.bam")), paste0(self$root_dir,
        "/processed/", stringr::str_replace(bamfiles[i], ".bam", ".tmpSrt.bam")))
      fs::file_move(paste0(self$root_dir, "/", stringr::str_replace(bamfiles[i], ".bam", ".tmpSrt.bam.bai")), paste0(self$root_dir,
        "/processed/", stringr::str_replace(bamfiles[i], ".bam", ".tmpSrt.bam.bai")))
      gc()
    }
  }, 
#' @method map2cpg4optimize
#' 将bedgraph文件映射到CpG岛或启动子区域并优化它们。
#'
#' @return 优化后的bedgraph文件。
  map2cpg4optimize = function() {
    print(paste("info, Step 3, Get CpGs or promoter regions and optimize the bedgraph files"))
    rrbs_map2cpgislands <- function(bedtools_exe, root_dir, type = c("cpg", "promoter"), cpg_bedfiles, output) {
      bedfiles <- list.files(root_dir, ".bedgraph", recursive = TRUE)
      fs::dir_create(output)
      for (i in 1:length(bedfiles)) {
        print(paste(i, "/", length(bedfiles), ",we are now working on ", bedfiles[i]))
        # bedtools intersect -a methylation.bedgraph -b annotation.gtf -wa -wb > annotated_methylation.bed
        system(paste(bedtools_exe, "intersect -a", paste0(root_dir, "/", bedfiles[i]), "-b", cpg_bedfiles, "-wa -wb >",
          paste0(output, "/", stringr::str_replace(bedfiles[i], ".bedgraph", paste0("_", type, ".bedgraph")))))
      }
      gc()
    }
    # 优化跟cpg岛匹配后的bedgraph文件的序列和甲基化信号值
    rrbs_optimize4cpgislands <- function(root_dir, output) {
      bedfiles <- list.files(root_dir, ".bedgraph")
      fs::dir_create(output)
      for (i in 1:length(bedfiles)) {
        bedfile <- data.table::fread(paste0(root_dir, "/", bedfiles[i]))
        print(paste(paste0(i, "/", length(bedfiles)), ", now we are working on", bedfiles[i]))
        colnames(bedfile) <- c("chr_num", "start_chrn", "end_chrn", "methy_value", "chr", "start", "end", "CpGs")
        cpg_seq <- bedfile %>%
          dplyr::select(chr, start, end, CpGs) %>%
          dplyr::mutate(chr_cpgs = paste0(chr, "_", CpGs)) %>%
          dplyr::distinct(chr_cpgs, .keep_all = TRUE) %>%
          dplyr::select(start, end, chr_cpgs)
        bedfile2 <- bedfile %>%
          dplyr::group_by(CpGs, chr) %>%
          dplyr::summarise(methy_value = mean(methy_value)) %>%
          dplyr::mutate(chr_cpgs = paste0(chr, "_", CpGs)) %>%
          dplyr::left_join(cpg_seq, by = "chr_cpgs") %>%
          dplyr::select(chr, start, end, methy_value, CpGs) %>%
          dplyr::arrange(chr)
        data.table::fwrite(bedfile2, paste0(output, "/", bedfiles[i]), quote = FALSE)
      }
    }
    rrbs_optimize4promoter <- function(root_dir, output) {
      print(paste("info, be careful, we will use at least 20GB RAM."))
      library(stringr)
      bedfiles <- list.files(root_dir, ".bedgraph")
      fs::dir_create(output)
      for (i in 1:length(bedfiles)) {
        bedfile <- data.table::fread(paste0(root_dir, "/", bedfiles[i]))
        print(paste(paste0(i, "/", length(bedfiles)), ", now we are working on", bedfiles[i]))
        colnames(bedfile) <- c("chr_num", "start_chrn", "end_chrn", "methy_value", "chr", "start", "end", "promoter",
          "unknow", "strand")
        bedfile <- bedfile %>%
          dplyr::mutate(promoter = str_split(promoter, "_")) %>%
          dplyr::mutate(promoter = sapply(promoter, `[`, 1))
        cpg_seq <- bedfile %>%
          dplyr::select(chr, start, end, promoter, strand) %>%
          dplyr::mutate(chr_cpgs = paste0(chr, "_", promoter, strand)) %>%
          dplyr::distinct(chr_cpgs, .keep_all = TRUE) %>%
          dplyr::select(chr, start, end, chr_cpgs)
        bedfile2 <- bedfile %>%
          dplyr::mutate(chr_cpgs = paste0(chr, "_", promoter, strand)) %>%
          dplyr::group_by(chr_cpgs) %>%
          dplyr::summarise(methy_value = mean(methy_value)) %>%
          dplyr::left_join(cpg_seq, by = "chr_cpgs") %>%
          dplyr::select(chr, start, end, methy_value, chr_cpgs) %>%
          dplyr::rename(promoter = chr_cpgs) %>%
          dplyr::arrange(chr)
        data.table::fwrite(bedfile2, paste0(output, "/", bedfiles[i]), quote = FALSE)
        gc()
      }
    }
    message(glue::glue("now we are on {self$type} mod."))
    if (self$type == "cpg") {
      rrbs_map2cpgislands(self$bedtools_exe, self$methyratio_dir, self$type, self$cpg_bedfiles, self$cpgmethy_dir)
      rrbs_optimize4cpgislands(self$cpgmethy_dir, self$cpgmethy_optimize)
      fs::dir_delete(self$cpgmethy_dir)
    } else {
      rrbs_map2cpgislands(self$bedtools_exe, self$methyratio_dir, self$type, self$promoter_bedfiles, self$promotermethy_dir)
      rrbs_optimize4promoter(self$promotermethy_dir, self$promotermethy_optimize)
      fs::dir_delete(self$promotermethy_dir)
    }
  }, 
#' @method pack2matrix
#' 将bedgraph文件打包为矩阵格式。
#'
#' @return 矩阵格式的数据框。
  pack2matrix = function() {

    rrbs_cpgBED2matrix <- function(root_dir, matrix_type = c("Beta-value", "M-value"), chrsex = "dame") {
      bedfiles <- list.files(root_dir, "\\.bedgraph", recursive = FALSE)
      union_cpgs <- list()
      for (i in 1:length(bedfiles)) {
        if (chrsex == "dame") {
          df_temp <- data.table::fread(paste0(root_dir, "/", bedfiles[i])) %>%
          dplyr::filter(chr != "chrX") %>%
          dplyr::filter(chr != "chrY") %>%
          dplyr::mutate(idx = paste0(chr, "~", start, "~", end, "~", CpGs))
          union_cpgs[[i]] <- df_temp$idx
        } else {
          df_temp <- data.table::fread(paste0(root_dir, "/", bedfiles[i])) %>%
          dplyr::mutate(idx = paste0(chr, "~", start, "~", end, "~", CpGs))
          union_cpgs[[i]] <- df_temp$idx
        }
      }
      union_cpg <- Reduce(intersect, union_cpgs)
      # 读取第一个bedgraph文件
      df_table <- data.table::fread(paste0(root_dir, "/", bedfiles[1])) %>%
        dplyr::filter(chr != "chrX") %>%
        dplyr::filter(chr != "chrY") %>%
        dplyr::mutate(idx = paste0(chr, "~", start, "~", end, "~", CpGs)) %>%
        dplyr::filter(idx %in% union_cpg) %>%
        dplyr::select(-CpGs)
      sample_id <- stringr::str_split(bedfiles[1], "_")[[1]][2]
      colnames(df_table) <- c("chr", "start", "end", sample_id, "idx")
      # 遍历剩余的bedgraph文件，并逐个进行合并
      for (i in 2:length(bedfiles)) {
        print(paste("working on item", i, "/", length(bedfiles)))
        temp_df <- data.table::fread(paste0(root_dir, "/", bedfiles[i])) %>%
          dplyr::filter(chr != "chrX") %>%
          dplyr::filter(chr != "chrY") %>%
          dplyr::mutate(idx = paste0(chr, "~", start, "~", end, "~", CpGs)) %>%
          dplyr::filter(idx %in% union_cpg) %>%
          dplyr::select(-all_of(c("chr", "start", "end", "CpGs")))
        sample_id <- stringr::str_split(bedfiles[i], "_")[[1]][2]
        colnames(temp_df) <- c(sample_id, "idx")
        df_table <- dplyr::left_join(df_table, temp_df, by = "idx")
      }

      df_table_idx <- df_table %>%
        dplyr::select(chr, start, end, idx)
      # 将df_table_idx写入文件
      data.table::fwrite(df_table_idx, "df_cpg_idx.txt", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
      # 重新整理df_table，移动idx列至最前面
      df_table <- df_table %>%
        dplyr::select(-all_of(c("chr", "start", "end"))) %>%
        dplyr::relocate(idx)
      # 根据matrix_type选择处理方式
      if (matrix_type == "M-value") {
        # 计算M-value
        matrixdf <- as.matrix(df_table[, -1])
        result <- log2(matrixdf/(1 - matrixdf))
        df <- as.data.frame(result) %>%
          dplyr::mutate(idx = df_table$idx) %>%
          dplyr::relocate(idx)
        colnames(df) <- colnames(df_table)
      } else {
        df <- df_table
      }
      # 将df保存为RDS文件
      saveRDS(df, "methylationSet_cpgs.RDS")
      return(df)
    }
    rrbs_promoterBED2matrix <- function(root_dir, matrix_type = c("Beta-value", "M-value"), chrsex = "dame") {
      bedfiles <- list.files(root_dir, "\\.bedgraph", recursive = FALSE)
      union_cpgs <- list()
      for (i in 1:length(bedfiles)) {
        if (chrsex == "dame") {
          df_temp <- data.table::fread(paste0(root_dir, "/", bedfiles[i])) %>%
          dplyr::filter(chr != "chrX") %>%
          dplyr::filter(chr != "chrY")
          dplyr::union_cpgs[[i]] <- df_temp$promoter
        } else {
          df_temp <- data.table::fread(paste0(root_dir, "/", bedfiles[i]))
          union_cpgs[[i]] <- df_temp$promoter
        }
      }
      union_cpg <- Reduce(intersect, union_cpgs)
      # 读取第一个bedgraph文件
      df_table <- data.table::fread(paste0(root_dir, "/", bedfiles[1])) %>%
        dplyr::filter(chr != "chrX") %>%
        dplyr::filter(chr != "chrY") %>%
        dplyr::filter(promoter %in% union_cpg) %>%
        dplyr::rename(dix = promoter)
      sample_id <- stringr::str_split(bedfiles[1], "_")[[1]][2]
      colnames(df_table) <- c("chr", "start", "end", sample_id, "idx")
      # 遍历剩余的bedgraph文件，并逐个进行合并
      for (i in 2:length(bedfiles)) {
        print(paste("working on item", i, "/", length(bedfiles)))
        temp_df <- data.table::fread(paste0(root_dir, "/", bedfiles[i])) %>%
          dplyr::filter(chr != "chrX") %>%
          dplyr::filter(chr != "chrY") %>%
          dplyr::filter(promoter %in% union_cpg) %>%
          dplyr::rename(dix = promoter) %>%
          dplyr::select(-all_of(c("chr", "start", "end")))
        sample_id <- stringr::str_split(bedfiles[i], "_")[[1]][2]
        colnames(temp_df) <- c(sample_id, "idx")
        df_table <- left_join(df_table, temp_df, by = "idx")
      }

      df_table_idx <- df_table %>%
        dplyr::select(chr, start, end, idx)
      # 将df_table_idx写入文件
      data.table::fwrite(df_table_idx, "df_promoter_idx.txt", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
      # 重新整理df_table，移动idx列至最前面
      df_table <- df_table %>%
        dplyr::select(-all_of(c("chr", "start", "end"))) %>%
        dplyr::relocate(idx)
      # 根据matrix_type选择处理方式
      if (matrix_type == "M-value") {
        # 计算M-value
        matrixdf <- as.matrix(df_table[, -1])
        result <- log2(matrixdf/(1 - matrixdf))
        df <- as.data.frame(result) %>%
          dplyr::mutate(idx = df_table$idx) %>%
          dplyr::relocate(idx)
        colnames(df) <- colnames(df_table)
      } else {
        df <- df_table
      }
      # 将df保存为RDS文件
      saveRDS(df, "methylationSet_promoter.RDS")
      return(df)
    }
    print(paste("info, Step 4, Get methylation matrix among samples && calculate M-value in option"))
    if (self$type == "cpg") {
      df <- rrbs_cpgBED2matrix(self$cpgmethy_optimize, self$matrix_type, self$chrsex)
    } else {
      df <- rrbs_promoterBED2matrix(self$promotermethy_optimize, self$matrix_type, self$chrsex)
    }
    print(paste("info, congratuations! You have successfully build a methylation matrix.You can find the methylation matrix in RDS format in ",
      getwd(), "/methylationSet.RDS"))
    return(df)
  }))
```
  
```{r example-samwiseclass}
object2 <- SamwiseClass$new(root_dir = "batch1117", type = "cpg")
```
  
```{r tests-samwiseclass}
test_that("samwiseclass works", {
  expect_true(inherits(SamwiseClass, "R6ClassGenerator")) 
})
```
  
# moriaclass
    
```{r function-moriaclass}
#' promoter with gene annotation
#' @name promoter_probe
#' @description A database of promoter island with gene annotation information.
#' @format A data frame with promoter island with gene annotation.

#' MoriaClass
#' 
#' MoriaClass:In the Mines of Moria, you can feel the past, and the shadow of the present despair.
#' this is an R6 object for TGCA_GEO_Miner/download
#' 
#' @field mine character NULL the id of TGCA project or GEO repo
#' @field Dwarf_worker character "TGCA"/"GEO" the repos
#' 
#' @return R6 object
#' 
#' @export
MoriaClass <- R6::R6Class(
  "TGCA_GEO_Miner", 
  public = list(
    mine = NULL,
    Dwarf_worker = NULL,
    
#' @param mine character NULL the id of TGCA project or GEO repo
#' @param Dwarf_worker character "TGCA"/"GEO" the repos
    initialize = function(mine = NULL,
                          Dwarf_worker = "TGCA") {
      self$mine <- mine
      self$Dwarf_worker <- Dwarf_worker
      self$info()
    },
#' @method info
#' 打印R6对象的信息
#' 
#' @return str
    info = function() {
      message("MoriaClass:In the Mines of Moria, you can feel the past, and the shadow of the present despair.this is an R6 object for TGCA_GEO_Miner/download")
    },
#' begin download
#' @method download task
#' @param sup logit download sup file when TRUE
#' @return list
    download = function(sup = TRUE){
      get_gdc_data <- function(project,dataca = "Transcriptome Profiling",
                               data_type = "Gene Expression Quantification"){
        library(SummarizedExperiment)
        if (dataca == "Clinical") {
          query_result <- TCGAbiolinks::GDCquery(project = project,
                                   data.category = dataca,
                                   data.format = "bcr xml") 
          
        } else {
          query_result <- TCGAbiolinks::GDCquery(
            project = project, 
            data.category = dataca,
            data.type = data_type,
            workflow.type = "STAR - Counts")
          process_query <- TCGAbiolinks::getResults(query_result ,cols = "cases") 
          index <- duplicated(process_query)
          process_query2 <- process_query[!index] 
          query_result <- TCGAbiolinks::GDCquery(
            project = project, 
            data.category = dataca,
            data.type = data_type,
            workflow.type = "STAR - Counts",
            barcode = process_query2)
        }
        TCGAbiolinks::GDCdownload(query_result,method="api")
        if (dataca == "Clinical") {
          data_pre <- TCGAbiolinks::GDCprepare_clinic(query_result, clinical.info = "patient")
          
        } else {
          data_pre <- TCGAbiolinks::GDCprepare(query_result)
        }
        return(data_pre)
      }
      
      if (self$Dwarf_worker == "TGCA"){
        library(SummarizedExperiment)
        tgca_gene <- get_gdc_data(self$mine)
        tgca_clinical <- get_gdc_data(self$mine,dataca = "Clinical")
        counts <- as.data.frame(assay(tgca_laml_gene))
        data <- as.data.frame(rowRanges(tgca_laml_gene))
        expr_count = cbind(gene_type=data$gene_type,gene_name=data$gene_name,counts)
        data <- list(
          arraydata = expr_count,
          pdata = tgca_clinical
        )
        return(data)
      } else if (self$Dwarf_worker == "GEO"){
        message("download from GEO, creating data dir...")
        fs::dir_create('temp')
        data <- GEOquery::getGEO(self$mine,destdir = 'temp')
        if (length(data) > 1){
          datalist <- list()
        } else {
          datalist <- NULL
        }
        
        for (i in 1:length(data)){
          arraydata <- data[[i]]@assayData$exprs
          pdata <- data[[i]]@phenoData@data
          supplementary_file = data[[i]]@experimentData@other$supplementary_file
          if (is.null(supplementary_file)) {
            supplementary_file <- NA
          }
          metadata <- data.frame(
            gseid = self$mine,
            platform = data[[i]]@annotation,
            title = data[[i]]@experimentData@title,
            abstract = data[[i]]@experimentData@abstract,
            summary =  data[[i]]@experimentData@other$summary,
            supplementary_file = supplementary_file,
            type = data[[i]]@experimentData@other$type,
            samplenum = nrow(data[[i]]@phenoData@data)
          )
        if (nrow(arraydata) == 0 & sup){
          message("array not found, download supplementary to data dir")
          fs::dir_create(paste0("data/",self$mine,"_",i))
          ftps <- metadata$supplementary_file[1]
          ftps <- stringr::str_split(ftps,"\n")
          ftps <- ftps[[1]]
          for (a in 1:length(ftps)){
            filename <- stringr::str_split(ftps[a],"/")
            filename <- filename[[1]]
            filename <- filename[length(filename)]
            localfilepath <- paste0("data/",self$mine,"_",i,"/",filename)
            download.file(ftps[a],localfilepath, method = "auto")
          }
        }
        templist <- list(
          arraydata = arraydata,
          pdata = pdata,
          metadata = metadata
        )
        if (is.null(datalist)){
          datalist <- templist
        } else {
          datalist[[i]] <- templist
        }
        }
        return(datalist)
      }else {
        stop("the Dwarf_worker should be TGCA/GEO.")
      }
    }
    )
  )
```
  
```{r example-moriaclass}
laml <- MoriaClass$new(mine = "TCGA-LAML",Dwarf_worker = "TGCA")
```
  
```{r tests-moriaclass}
test_that("moriaclass works", {
  expect_true(inherits(MoriaClass, "R6ClassGenerator")) 
})
```


# EntClass
    
```{r function-EntClass}
#' EntClass
#' 
#' EntClass: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.
#' this is an R6 object for general array/matrix
#' 
#' @field array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @field array_bk data.frame the back up the old data.frame of expression/methylation matrix data, first column is the
#' probel id
#' @field pdata data.frame data.frame of the clinical data of the related matrix data
#' @field probel vector the probel of the matrix
#' @field group_index char the colname of the group infomation in pdata
#' @field batch_index char the colname of the batch_index infomation in pdata
#' @field barcode char the colname of the barcode infomation in pdata
#' @field pca data.frame the PCA analysis result
#' @field tsne data.frame the T-SNE analysis result
#' @field removebatch_array data.frame the array with batch effects removed
#' @field DA_result data.frame the differential analysis result
#' @field projectType expr or methy
#' @return R6 object
#' 
#' @export
EntClass <- R6::R6Class(
  "EntClass/MatrixSet",
  lock_objects = FALSE,
  public = list(
    array = NA,
    array_bk = NA,
    pdata = NA,
    probel = NA,
    group_index = NA,
    batch_index = NA,
    barcode = NA,
    pca = NA,
    tsne = NA,
    removebatch_array = NA,
    DA_result = NA,
    projectType = NA,
#' @param array data.frame data.frame of expression/methylation matrix data, first column is the probel id
#' @param pdata data.frame data.frame of the clinical data of the related matrix data
#' @param group_index char the colname of the group infomation in pdata
#' @param batch_index char the colname of the batch_index infomation in pdata
#' @param barcode_index char the colname of the barcode infomation in pdata
#' @param normalized logit auto normalized when true
#' @param remove_batch logit auto remove batch effect when true
#' @param differential logit auto differential analysis when true
#' @param projectType expr or methy
    initialize = function(array = NULL,pdata = NULL,
                          group_index = "group",batch_index = "batch",
                          barcode_index = "sampleid",normalized = FALSE,
                          remove_batch = FALSE,differential = FALSE,
                          projectType = c("expr","methy")
                          ){
      self$projectType <- projectType
      if (is.null(array)){
      self$array <- NULL
      self$pdata <- NULL
      self$probel <- NULL
      }else {
      self$array <- array %>% dplyr::select(all_of(c(colnames(array)[1],pdata[[barcode_index]])))
      self$pdata <- pdata
      self$probel <- array[,1]
      }
      self$group_index <- group_index
      self$batch_index <- batch_index
      self$barcode <- barcode_index
      if(normalized){
        self$normalization_transform()
      }
      if (remove_batch){
        self$removeBatch()
      }
      if (differential){
        self$DifferentAnalysis_workflow()
      }
      self$info()
    },
    #' @method info
    #' 打印R6对象的信息
    #' 
    #' @return str
    info = function(){
      message("EntClass/MatrixSet: We are not hasty. What we do, we do after long consideration and mostly we do not do anything.this is an R6 object for general array/matrix")
    },
    #' @method use_remove batch
    #' @return data.frame
    use_removebatch = function(){
      self$array_bk <- self$array
      self$array <- self$removebatch_array
    },
    #' @method probel annotate
    #' @param methyltype chr promoter or cpg
    #' @return data.frame
    probel_annotate = function(methyltype = c("promoter","cpg")){
      if (self$projectType == "expr"){ 
        ensembl2symbol <- function() {
          library(org.Hs.eg.db)
          library(biomaRt)
          # 连接到biomaRt数据库
          mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl")
          # 获取ENSEMBL到symbol的映射
          ensembl2symbol <- getBM(attributes = c("ensembl_gene_id", "external_gene_name"),
                                filters = "ensembl_gene_id",
                                values = ensembl_ids,
                                mart = mart)
          # 返回映射结果
          return(ensembl2symbol)
        }
        rnaseq_annote4matrix <- function(mds_expr_matrix,duplicate_method = "avg"){
          prfix <- rep(NA,nrow(mds_expr_matrix))
          for (i in 1:nrow(mds_expr_matrix)){
            prfix[i] <- stringr::str_sub(mds_expr_matrix$GENEID[i],1,4)
            }
          g_id <- mds_expr_matrix %>% 
            mutate(prefix = prfix) %>% 
            filter(prefix == "ENSG")
          g_id2 <- g_id$GENEID
          ff <- ensembl2symbol(g_id2)
          colnames(ff) <- c("GENEID","symbol")
          g_id <- g_id %>% 
            dplyr::select(-prefix) %>% 
            left_join(ff,by = "GENEID")
          for (i in 1:nrow(g_id)){
            if (is.na(g_id$symbol[i]) | is.null(g_id$symbol[i])){
              next
              }else {
                g_id$GENEID[i] <- g_id$symbol[i]  
              }
            }
          g_id <- g_id %>% 
            dplyr::select(-symbol) 
          if (duplicate_method == "avg"){
            g_id2 <- aggregate(.~GENEID,mean,data=g_id)
            }else {
              g_id2 <- aggregate(.~GENEID,max,data=g_id)
              }
          g_id2 <- g_id2 %>% filter(!is.null(GENEID)) %>% filter(!is.na(GENEID)) %>% filter(GENEID != "")
          rownames(g_id2) <- g_id2$GENEID
          return(g_id2)
          }

        self$array <- rnaseq_annote4matrix(mds_expr_matrix = self$array,duplicate_method = "avg")
        if(!is.na(self$removebatch_array)){
          self$removebatch_array <- rnaseq_annote4matrix(mds_expr_matrix = self$removebatch_array ,
                                                         duplicate_method = "avg")
        }
        self$probel <- self$array[1,]
      } else {
        rrbs_annote4DMP <- function(DMP_df,type = "cpg",
                            cpg_bedgraph){
          unannote_list <- data.frame(idx = DMP_df)
          if (type == "promoter"){
            g_id <- cpg_bedgraph
            g_id <- g_id %>%
                dplyr::select(-gene_id) %>%
                filter(idx %in% unannote_list$idx)
            } else {
              g_id <- cpg_bedgraph
              for (i in 1:nrow(g_id)){
                if (is.na(g_id$symbol[i]) | is.null(g_id$symbol[i])){
                  g_id$symbol[i] <- g_id$idx[i]
                  }else {
                    next
                  }
                }
              g_id <- g_id %>%
                dplyr::select(-gene_id) %>%
                filter(idx %in% unannote_list$idx)
            }
          return(g_id)
        }
        
        if (methyltype == "cpg"){
          referdata <- cpg_probe
        } else {
          referdata <- promoter_probe
        }
        
        self$probel <- rrbs_annote4DMP(self$probel, type = methyltype, cpg_bedgraph = referdata)
        
      }
    },

    #' @method remove Batch
    #' @return matrix
    removeBatch = function(){
      rrbs_ComBat2batcheffects <- function(beta,
                                     pd,
                                     variablename = "group",
                                     batchname="batch",
                                     logitTrans=TRUE){
        print("this function is adopted from chAMP.")
        if(length(which(is.na(beta)))>0) message(length(which(is.na(beta)))," NA are detected in your beta Data Set, which may cause fail or uncorrect of runCombat analysis.")
        if ("data.frame" %in% class(beta)){print("we repuire a methylationSet in the format of data.frame as input")}
        if ("data.frame" %in% class(pd)){print("we repuire a pd in the format of data.frame as input")}
        if(is.null(variablename) | !variablename %in% colnames(pd)) stop("variablename parameter MUST contains variable in pd file.")
        valid.idx <- which(!colnames(pd) == variablename & apply(pd,2,function(x) length(unique(x)))!=1)
        if(length(valid.idx)==0) stop("There is no valid factor can be corrected. Factor can be corrected must contian at least two phenotypes. Also batch factors can be variable factor. Please check if your covariates fulfill these requirement.")
        PhenoTypes.lv_tmp <- pd[,valid.idx]
        PhenoTypes.lv_tmp <- apply(PhenoTypes.lv_tmp,2,function(x) as.character(x))
        PhenoTypes.lv <- as.data.frame(apply(PhenoTypes.lv_tmp,2,function(x) if(inherits(x,"numeric"))
          as.factor(as.numeric(as.factor(x)))))
        if(!is.null(rownames(pd))) rownames(PhenoTypes.lv) <- rownames(pd)
        if(ncol(PhenoTypes.lv)>=1){
          message("<< Following Factors in your pd(sample_sheet.csv) could be applied to Combat: >>")
          sapply(colnames(PhenoTypes.lv_tmp),function(x) message("<",x,">(",class(PhenoTypes.lv[[x]]),")"))
          message("[Combat have automatically select ALL factors contain at least two different values from your
                  pd(sample_sheet.csv).]")
          }else{
            stop("You don't have even one factor with at least two value to be analysis. Maybe your factors contains only one value, no variation at all...")
            }
        if(ncol(pd) > ncol(PhenoTypes.lv)){
          message("\n<< Following Factors in your pd(sample_sheet.csv) can not be corrected: >>")
          sapply(setdiff(colnames(pd),colnames(PhenoTypes.lv)),function(x) message("<",x,">"))
          message("[Factors are ignored because they are conflict with variablename, or they contain ONLY ONE value
                  across all Samples, or some phenotype contains less than 2 Samples.]")
          }
        if(all(batchname %in% colnames(PhenoTypes.lv))){
          message("As your assigned in batchname parameter: ",paste(batchname,collapse=",")," will be corrected by
                  Combat function.")
          }else{
            stop(setdiff(batchname,colnames(PhenoTypes.lv))," factors is not valid to run Combat, please recheck your
                 dataset.")
            }
        beta_2 <- beta
        beta_colnames <- colnames(beta)
        beta_rownames <- beta[,1]
        beta <- beta[,-1]
        if(min(beta)<=0 & logitTrans == TRUE){
          message("Zeros in your dataset have been replaced with smallest positive value.")
          beta[beta<=0] <- min(beta[beta > 0])
          }
        print(beta)
        print("check beta in zeros")
        rownames(beta) <- beta_rownames
        #Following four find empirical hyper-prior values
        aprior <- function(gamma.hat) {
          m <- mean(gamma.hat)
          s2 <- var(gamma.hat)
          (2*s2 + m^2) / s2
        }
        
        bprior <- function(gamma.hat){
            m <- mean(gamma.hat)
            s2 <- var(gamma.hat)
            (m*s2 + m^3) / s2
        }
        innercombat <- function(beta,beta_2,batch_temp,formdf,pd,logitTrans){
          library(minfi)
          if(logitTrans){
            beta <- logit2(beta)
            }
          print(formdf)
          print(batch_temp)
          mod <- model.matrix(formdf,data=pd)
          print(mod)
          message("Generate mod success. Started to run ComBat, which is quite slow...")
          combat <- sva::ComBat(dat=beta,batch=batch_temp,mod=mod)
          print("checked")
          if(logitTrans){
            combat=ilogit2(combat)
            }
          if (is.na(combat[1,1])){
            print("found na,try another")
            combat <- sva::ComBat(dat = beta_2[,-1],pd$batch,mod = mod)
            }
          return(combat)
          }
        library(sva)
        #i = 1
        for(i in 1:length(batchname)){
          message("\n<< Start Correcting ",batchname[i]," >>")
          if(i+1 <= length(batchname)){
            formdf <- as.formula(paste(" ~ ",paste(c(variablename,batchname[(i+1):length(batchname)]),collapse=" +
                                                   "),sep=""))
            }else{
              formdf <- as.formula(paste(" ~",variablename))
              }
          batch_temp <- pd[,batchname[i]] %>% unlist()
          print(batch_temp)
          print(formdf)
          beta <- innercombat(beta,beta_2,batch_temp,formdf,pd = pd,logitTrans = logitTrans)
          }
        beta <- as.data.frame(beta)
        beta <- beta %>% mutate(idx = beta_rownames) %>% relocate(idx)
        if(is.null(beta)){
          message("Sorry, Combat process run failed. Your old dataset will be returned.")
          return(beta_2)
          }else{
            message("Combat process run success. Corrected dataset will be returned.")
            return(beta)
            }
        message("[<<< COMBAT END >>>]")
        }
      if (self$projectType == "expr"){
        design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
        mat = limma::removeBatchEffect(self$array[,-1], batch = self$pdata[[self$batch_index]], design = design)
        mat <- mat %>% dplyr::mutate(GENEID = self$probel) %>% relocate(GENEID)
        self$removebatch_array <- mat
      } else {
        mat <- rrbs_ComBat2batcheffects(beta = self$array,
                                     pd = self$pdata,
                                     variablename = self$group_index,
                                     batchname=self$batch_index,
                                     logitTrans=TRUE)
        self$removebatch_array <- mat
      }
      
    },
    #' @method feature filter
    #' @param pct num range(0-1), the ratetio to filter
    #' @return matrix
    feature_filter = function(pct = 0.8){
      data_expr <- self$array[,-1]
      # Calculating variation
      cv_value <- apply(data_expr,1, function(x) sd(x,na.rm = TRUE) / mean(x,na.rm = TRUE) * 100)
      # Filtering
      self$array <- self$array %>%
        dplyr::mutate(cv = cv_value) %>% 
        dplyr::top_frac(pct,cv) %>% 
        dplyr::select(-cv)
    },
    #' @method Plot PCA
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    PlotPCA = function(ntop = 500,batchremove = FALSE){
      if (batchremove){
        array <- self$removebatch_array[,-1] %>% as.matrix()
      } else {
        array <- self$array[,-1] %>% as.matrix()
      }
        # calculate the variance for each row
        
        pdata <- self$pdata
        batchname <- c(self$group_index,self$batch_index)
        rv <- rowVars(array)
        # select the ntop rows by variance
        select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
        # perform a PCA on the data in assay(x) for the selected genes
        pca <- prcomp(t(array[select,]))
        # the contribution to the total variance for each component
        percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
        if (!all(batchname %in% colnames(pdata))) {
          stop("the argument 'intgroup' should specify columns of pd")
        }
        intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
        # add the intgroup factors together to create a new grouping factor
        group <- if (length(batchname) > 1) {
          factor(apply( intgroup.df, 1, paste, collapse=":"))
        } else {
          pd[[batchname]]
        }
        # assembly the data for the plot
        d <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], groups=group, intgroup.df, name=colnames(object))
        self$pca <- d
        p <- ggplot(d, aes(PC1, PC2)) +
          geom_point(aes(shape = .[[self$group_index]], color = .[[self$batch_index]]), size = 3)
        return(p)
    },
    #' @method Plot SNE
    #' @param ntop num select the ntop rows by variance, default as 500
    #' @param dim num the dim of Rtsne,default as 2
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    PlotSNE = function(ntop = 500,dim = 2,batchremove = FALSE){
      # To-Do,some var should be fix in tsne analysis
      # calculate the variance for each row
      if (batchremove){
        array <- self$removebatch_array[,-1] %>% as.matrix()
      } else {
        array <- self$array[,-1] %>% as.matrix()
      }
      pdata <- self$pdata
      batchname <- c(self$group_index,self$batch_index)
      rv <- rowVars(array)
      # select the ntop rows by variance
      select <- order(rv, decreasing=TRUE)[seq_len(min(ntop, length(rv)))]
      # perform a tSNE on the data in assay(x) for the selected genes
      tSNE_result <- Rtsne::Rtsne(array[select,], dims = dim)
      # the contribution to the total variance for each component
      percentVar <- pca$sdev^2 / sum( pca$sdev^2 )
      if (!all(batchname %in% colnames(pdata))) {
        stop("the argument 'intgroup' should specify columns of pd")
      }
      intgroup.df <- as.data.frame(pdata[,batchname, drop=FALSE])
      # add the intgroup factors together to create a new grouping factor
      group <- if (length(batchname) > 1) {
        factor(apply( intgroup.df, 1, paste, collapse=":"))
      } else {
        pd[[batchname]]
      }
      # assembly the data for the plot
      d <- data.frame(X = tSNE_result$Y[, 1], Y = tSNE_result$Y[, 2], groups = group)
      self$tsne <- d
      p <- ggplot(d, aes(X, Y)) +
        geom_point(aes(color = groups), size = 3)
      return(p)
    },
    #' @method to ExprSet
    #' @return R6_object
    toExprSet = function(){
      newitem <- ExprEntClass$new(self$array,self$pdata,
                                  self$group_index,self$batch_index,
                                  self$barcode_index,self$removebatch_array,
                                  self$DA_result)
      return(newitem)
    },
    #' @method to ExprSet
    #' @return R6_object
    toMethySet = function(){
      newitem <- MethylEntClass$new(self$array,self$pdata,
                                    self$group_index,self$batch_index,
                                    self$barcode_index,self$removebatch_array,
                                    self$DA_result)
      return(newitem)
    },
    #' @method normalization transform
    #' @param .keep logit whether to replace the old array directly,default as TRUE (create the normal_array)
    #' @return data.frame
    normalization_transform = function(.keep = TRUE){
      matrixdf <- self$array[,-1] %>% as.matrix()
      matrixdf <- log2(matrixdf) %>% 
        as.data.frame(result) %>% mutate(idx = self$probel) %>% relocate(idx)
      if (.keep){
        self$normal_array <- matrixdf
      } else {
        self$array <- matrixdf
      }
    },
    #' @method Different Analysis_workflow 
    #' @param adjust.method chr the adjust.method of limma
    #' @param adjPVal num the adjust p value, default as 0.05
    #' @param batchremove logit use batchremove_array when true
    #' @return data.frame
    DifferentAnalysis_workflow = function(adjust.method = "BH",adjPVal = 0.05,batchremove = FALSE){
      if (batchremove){
        beta <- self$removebatch_array[,-1] 
        rownames(beta) <- self$removebatch_array[,1] 
      } else {
        beta <- self$array[,-1]
        rownames(beta) <- self$array[,1]
      }
      library(limma)
      design <- model.matrix( ~ 0 + factor(self$pdata[[self$group_index]]))
      colnames(design) <- levels(factor(self$pdata[[self$group_index]]))
      contrast.matrix <- makeContrasts(contrasts=paste(colnames(design)[2:1],collapse="-"), levels=colnames(design))
      message("Contrast Matrix")
      print(contrast.matrix)
      fit <- lmFit(beta, design)
      fit2 <- contrasts.fit(fit,contrast.matrix)
      tryCatch(fit3 <- eBayes(fit2),
               warning=function(w) 
               {stop("limma failed, No sample variance.\n")})
      DMP <- topTable(fit3,coef=1,number=nrow(beta),adjust.method=adjust.method,p.value=adjPVal)
      message("You have found ",sum(DMP$adj.P.Val <= adjPVal), " significant items with a ",adjust.method," adjusted P-value below ", adjPVal,".")
      if (nrow(DMP) == 0){
        message("seems bad,adjusting")
        DMP <- topTable(fit3,coef=1,n = Inf)
      }
      message("Calculate done.")
      self$DA_result <- DMP
    }
  )
)

```
  
```{r example-EntClass}
Entitem <- EntClass$new(array = NULL,pdata = NULL)
```
  
```{r tests-EntClass}
test_that("EntClass works", {
  expect_true(inherits(EntClass, "R6ClassGenerator")) 
})
```
  


# ExprEntClass
    
```{r function-ExprEntClass}
#' ExprEntClass
#' 
#' ExprEntClass: We are not orcs, to be smashed and driven. We are Ents, and we have our own ways.
#' this is an R6 object for RNA expression array/matrix analysis,herited from EntClass.
#' 
#' @return R6 object
#' 
#' @export
ExprEntClass <- R6::R6Class(
  "ExprEntClass/ExprSet",
  inherit = EntClass,
  public = list(
    #' @method Plot hetmap
    #' @param p_thred default as 0.05
    #' @param logFC_thred default as 1
    #' @param topn default as 30
    #' @return fig
    Plot_hetmap = function(p_thred = 0.05,logFC_thred = 1 ,topn = 30){
      if (!is.null(self$removebatch_array)){
        array <- self$removebatch_array
      } else if (!is.null(self$normal_array)){
        array <- self$normal_array
      }else {
        array <- self$array
      }
      library(pheatmap)
      group_sample <- self$pdata %>% dplyr::arrange(.[[self$group_index]])
      group_order <- group_sample[[self$barcode]]
      expr_normal_df2 <- self$array %>% 
        dplyr::select(all_of(group_order))
      rownames(expr_normal_df2) <- self$array[,1]
      group_list <- factor(group_sample[[self$group_index]])
      deg <- self$DA_resutl %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change != "NOT") %>% 
        dplyr::arrange('adj.P.Val')
      display_gene = rownames(deg)
      cg=c(names(head(sort(display_gene),topn)),names(tail(sort(display_gene),topn)))
      n=t(scale(t(expr_normal_df2[cg,])))
      n[n>2]=2
      n[n< -2]= -2
      n[1:4,1:4]
      ac=data.frame(group_list=group_list)
      rownames(ac)=colnames(n)
      p <- pheatmap(n,show_colnames =F,show_rownames = T,annotation_col=ac)
      library(ggplotify)
      p <- as.ggplot(p) + theme(plot.margin = margin(l = 5, r = 10))
      return(p)
    },
    #' @method Plot vocalno
    #' @param style_id default as 1,2
    #' @param logFC_thred default as 1
    #' @return fig
    Plot_vocalno = function(style_id,logFC_thred){
      need_deg=data.frame(symbols=rownames(self$DA_resutl), 
                          logFC=self$DA_resutl[["logFC"]], 
                          p=self$DA_resutl[["adj.P.Val"]])
      self$vocano <- AnnoProbe::deg_volcano(need_deg,style_id,logFC_thred = logFC_thred)
    },
    #' @method gsva enrich
    #' @param geneSets list the geneSets list
    #' @return data.frame
    gsva_enrich = function(geneSets){
      df <- self$array[,-1]
      rownames(df) <- self$array[,1] 
      df <- df %>%
        as.matrix() %>%
        as.integer() %>% 
        GSVA::gsva(geneSets, method = "md",
             ssgsea.norm = F, verbose = TRUE)  # donot norm
      return(df)
    },
    #' @method gene enrich
    #' @param pathwaydb chr go or kegg
    #' @param genedb data.frame the genedb data
    #' @return list
    gene_enrich = function(pathwaydb,genedb = Entrez_Gene_Id_db){
      enrichment_in_action <- function(df,types){
        if (types == "go"){
          result <- clusterProfiler::enrichGO(df, 'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01)
        } else {
          result <- clusterProfiler::enrichKEGG(df, organism = "hsa",
                                                keyType = "kegg",
                                                pvalueCutoff = 0.01,
                                                pAdjustMethod = "BH",
                                                minGSSize = 10,
                                                maxGSSize = 500,
                                                qvalueCutoff = 0.2,
                                                use_internal_data = FALSE)
        }
      }
      gene2entrez <- function(genelist,db = genedb){
        # need further tidy evaluation
        db %>% 
          dplyr::filter(SYMBOL %in% genelist) %>% 
          dplyr::select(ENTREZID) %>% 
          as.vector() %>% 
          unlist()
      }
      enrichlist <- list()
      for (changeType in c("UP","DOWN")){
        DEG <- self$DA_result %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change == changeType) %>% 
        dplyr::rownames() %>%
        gene2entrez(genedb) %>% 
        as.vector() %>% unique() %>% 
        enrichment_in_action(types = pathwaydb)
      
      Go_result <- DEG@result %>% 
        tidyr::separate(col=GeneRatio,into = c("GR1", "GR2"), sep = "/") %>% 
        tidyr::separate(col=BgRatio, into = c("BR1", "BR2"), sep = "/") %>% 
        dplyr::mutate(enrichment_factor = (as.numeric(GR1)/as.numeric(GR2))/(as.numeric(BR1)/as.numeric(BR2))) %>% 
        dplyr::mutate(generatio = (as.numeric(GR1)/as.numeric(GR2))) %>% 
        dplyr::arrange(-enrichment_factor)
      enrichlist[[changeType]] <- Go_result 
      }
     return(enrichlist)
    }
  )
)
```
  
```{r example-ExprEntClass}
ExprEntitem <- ExprEntClass$new()
```
  
```{r tests-ExprEntClass}
test_that("ExprEntClass works", {
  expect_true(inherits(ExprEntClass, "R6ClassGenerator")) 
})
```


# MethylEntClass
    
```{r function-MethylEntClass}
#' MethylEntClass
#' 
#' MethylEntClass : The world is changing. I feel it in the water. I feel it in the earth. I smell it in the air. Much that once was is now lost, for none now live who remember it.
#' 
#' @return R6_object
#' 
#' @export
MethylEntClass <- R6::R6Class(
  "MethylEntClass/MethySet",
  inherit = EntClass,
  public = list(
    #' @method Plot hetmap
    #' @param p_thred default as 0.05
    #' @param logFC_thred default as 1
    #' @param topn default as 30
    #' @return fig
    Plot_hetmap = function(p_thred = 0.05,logFC_thred = 1 ,topn = 30){
      library(pheatmap)
      group_sample <- self$pdata %>% dplyr::arrange(.[[self$group_index]])
      group_order <- group_sample[[self$sample_index]]
      expr_normal_df2 <- self$array %>% 
        dplyr::select(all_of(group_order))
      rownames(expr_normal_df2) <- self$array[,1]
      group_list <- factor(group_sample[[self$group_index]])
      deg <- self$DA_result %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change != "NOT") %>% 
        dplyr::arrange('adj.P.Val')
      display_gene = rownames(deg)
      cg=c(names(head(sort(display_gene),topn)),names(tail(sort(display_gene),topn)))
      n=t(scale(t(expr_normal_df2[cg,])))
      n[n>2]=2
      n[n< -2]= -2
      n[1:4,1:4]
      ac=data.frame(group_list=group_list)
      rownames(ac)=colnames(n)
      p <- pheatmap(n,show_colnames =F,show_rownames = T,annotation_col=ac)
      library(ggplotify)
      as.ggplot(p) + theme(plot.margin = margin(l = 5, r = 10))
    },
    #' @method Plot vocalno
    #' @param style_id default as 1,2
    #' @param logFC_thred default as 1
    #' @return fig
    Plot_vocalno = function(style_id,logFC_thred){
      need_deg=data.frame(symbols=rownames(self$DMP_table), logFC=self$DMP_table[["logFC"]], p=self$DMP_table[["adj.P.Val"]])
      AnnoProbe::deg_volcano(need_deg,style_id,logFC_thred = logFC_thred)
    },
    #' @method matrix annotate
    #' @param type chr promoter or cpg
    #' @param df_object the converted data
    #' @return data.frame
    matrix_annotate = function(df_object = c("DA_result","array"),type = "cpg"){
      
      rrbs_annote4DMP <- function(DMP_df,type = "cpg",
                                  cpg_bedgraph){
        unannote_list <- rownames(DMP_df)
        if (type == "promoter"){
           g_id <- cpg_bedgraph
           g_id <- g_id %>%
             dplyr::select(-gene_id) %>%
             filter(idx %in% unannote_list)
        } else {
          g_id <- data.table::fread(cpg_bedgraph) 
          for (i in 1:nrow(g_id)){
            if (is.na(g_id$symbol[i]) | is.null(g_id$symbol[i])){
              g_id$symbol[i] <- g_id$idx[i]
            }else {
              next
            }
          }
          g_id <- g_id %>% 
            dplyr::select(-gene_id) %>%
            filter(idx %in% unannote_list)
        }
        DMP_df_colnames <- c(colnames(g_id),colnames(DMP_df))
        row_df <- rownames(DMP_df)
        DMP_df <- DMP_df %>%  
          mutate(idx = row_df) %>% 
          filter(idx %in% g_id$idx) %>% 
          left_join(g_id,by = "idx") %>% 
          dplyr::select(all_of(c("idx",DMP_df_colnames) ))
        return(DMP_df)
      }
       if (type == "cpg"){
         referdata <- cpg_probe
         } else {
           referdata <- promoter_probe
         }
      if (df_object == "DA_result"){
        convertdata <- self$DA_result
      }else {
        convertdata <- self$array
      }
      
      df <- rrbs_annote4DMP(DMP_df = convertdata ,type = type,
                                  cpg_bedgraph = referdata)
      
      return(df)
    },
    
    #' @method gene enrich
    #' @param pathwaydb chr go or kegg
    #' @param genedb data.frame the genedb data
    #' @return list
    gene_enrich = function(pathwaydb,genedb = Entrez_Gene_Id_db){
      enrichment_in_action <- function(df,types){
        if (types == "go"){
          result <- clusterProfiler::enrichGO(df, 'org.Hs.eg.db', ont="BP", pvalueCutoff=0.01)
        } else {
          result <- clusterProfiler::enrichKEGG(df, organism = "hsa",
                                                keyType = "kegg",
                                                pvalueCutoff = 0.01,
                                                pAdjustMethod = "BH",
                                                minGSSize = 10,
                                                maxGSSize = 500,
                                                qvalueCutoff = 0.2,
                                                use_internal_data = FALSE)
        }
      }
      gene2entrez <- function(genelist,db = genedb){
        # need further tidy evaluation
        db %>% 
          dplyr::filter(SYMBOL %in% genelist) %>% 
          dplyr::select(ENTREZID) %>% 
          as.vector() %>% 
          unlist()
      }
      enrichlist <- list()
      for (changeType in c("UP","DOWN")){
        DEG <- self$DA_result %>% 
        dplyr::mutate(change = ifelse(adj.P.Val < p_thred & abs(logFC) > logFC_thred,
                                      ifelse(logFC > logFC_thred ,'UP','DOWN'),'NOT')) %>% 
        dplyr::filter(change == changeType) 
        
        DEG <- DEG$symbol %>%
        gene2entrez(genedb) %>% 
        as.vector() %>% unique() %>% 
        enrichment_in_action(types = pathwaydb)
      
      Go_result <- DEG@result %>% 
        tidyr::separate(col=GeneRatio,into = c("GR1", "GR2"), sep = "/") %>% 
        tidyr::separate(col=BgRatio, into = c("BR1", "BR2"), sep = "/") %>% 
        dplyr::mutate(enrichment_factor = (as.numeric(GR1)/as.numeric(GR2))/(as.numeric(BR1)/as.numeric(BR2))) %>% 
        dplyr::mutate(generatio = (as.numeric(GR1)/as.numeric(GR2))) %>% 
        dplyr::arrange(-enrichment_factor)
      enrichlist[[changeType]] <- Go_result 
      }
     return(enrichlist)
    },
    #' @method convert Beta2M_value
    #' @return data.frame
    Mvalue_transform = function( ){
      matrixdf <- self$array[,-1] %>% as.matrix()
      result <- matrixdf / (1 - matrixdf)
      df <- as.data.frame(result) %>% mutate(idx = self$probel) %>% relocate(idx)
      return(df)
    }
  )
)
```
  
```{r example-MethylEntClass}
MethylEnt <- MethylEntClass$new()
```
  
```{r tests-MethylEntClass}
test_that("MethylEntClass works", {
  expect_true(inherits(MethylEntClass, "R6ClassGenerator")) 
})
```
  


```{r development-inflate, eval=FALSE}
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_first.Rmd")
```

<!-- 
- Verify your `"DESCRIPTION"` file has been updated
- Verify your function is in `"R/"` directory
- Verify your test is in `"tests/testthat/"` directory
- Verify this Rmd appears in `"vignettes/"` directory 
-->
